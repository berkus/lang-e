This tcc distribution comes with a 'configure' file generated by the GNU
autoconf utility, which should help make installation straightforward.


0 Index
-------

1 Things you should do before beginning installation

2 Installation procedure
2.1 Running configure
2.2 Running make
2.3 Important note for Solaris users
2.4 Compiling with optimizations

3 Using tcc with SimpleScalar


1 Things you should do before beginning installation
----------------------------------------------------

tcc needs a few other programs in order to build and install cleanly.  In
particular, the following programs should be in your path:

	* GNU make
	* GNU bison and flex
	* the GNU C compiler and preprocessor
	* perl (4.0 or greater)
	* as and ld
	* find and xargs (optional: only used to "make clean" in the top-level
	  makefile)
	* for solaris, GNU binutils (see Section 2.3)

GNU make is necessary because all the makefiles use the VPATH facility which
allows build directories to be easily separated from source trees.  GNU make is
(as far as I know) the only make which supports this.

Bison and flex are required to build bpp, a code generator generator for vcode.
You may be able to get away with yacc instead of bison, but you probably need
flex: lex generates illegal C for the bpp lexer.

GNU cpp is needed because tcc does not come with its own C preprocessor.
tcc uses features of GNU cpp which may not be available with your system C
compiler's cpp, so please make sure that GNU cpp appears in your path before
other cpps before running configure.

perl is necessary because it is used to generate much of the vcode back end
from compact specifications, as well as to automatically generate icode back
ends.


2 Installation procedure
------------------------

If you are in the directory that contains this INSTALL file (henceforth
referred to as $install), you should be able to build and install tcc into this
directory in two steps:

	% ./configure
	% gmake

The following sections give more details.

2.1 Running configure
---------------------

'configure' is a shell script which attempts to guess correct values for
system-dependent variables used during compilation, and uses this information
to generate Makefiles from the 'Makefile.in' files present in each directory.

If you are on a DECstation running Ultrix or on a Sun SparcStation running
SunOS or Solaris, you should obtain the default behavior (which installs tcc
into $install/bin) by simply typing 'configure', and need not read the rest of
this section.

Among other things, 'configure' determines the directory structure of the
installation.  This structure is defined by the following variables:
	prefix		a prefix used in constructing the default values of
			variables below
	srcdir		the directory where source files are stored
	builddir	the directory for putting object files and temporary
			files required for builds
	bindir		the directory for installing executable programs that
			users can run
	libdir		the directory for installing executables to be
			run by the compiler driver (rather than users
			themselves), and for storing libraries and other
			system-dependent code
	includedir	the directory for installing header files

By default, configure sets prefix=$install.  The 'Makefile.in' files are set up
so that then:
	srcdir		= prefix
	builddir	= prefix/build
	bindir		= prefix/bin
	libdir		= prefix/lib
	includedir	= prefix/include/<host-cpu>/<host-vendor>

If this is not to your liking, you can:
	1. run configure with different arguments or from a different directory
	2. edit the 'Makefile.in' or 'Makefile' files

If you want to separate the build from the sources (for example, to have builds
for different architectures side-by-side), you could do:
	% cd <build-directory>
	% /ABSOLUTE/PATH/TO/tcc-1.0/configure
	% gmake

IMPORTANT: use the absolute path (as opposed to a relative path) to
tcc/configure when building in a directory other than the source directory;
this is necessary for the recursive build process of the various tcc modules to
work correctly.

2.2 Running make
----------------

Invoking GNU make in $install after running 'configure' should build and
install tcc automatically.

You should be aware, however, that the driver is built by combining the
platform-independent file $install/src/tcc/tcc.c (a slightly modified version
of etc/lcc.c in the lcc distribution) with a platform-dependent file, which
should reside in $install/config/sys.  We provide 3 platform-dependent files:
mips-ultrix.c, sparc-sunos.c, and sparc-solaris.c.  These correspond to the
three platforms currently supported by tcc.  The top-level Makefile knows the
target architecture and OS, and it automatically selects one of these three
files when building the tcc driver.  Nonetheless, the settings in these three
files may not correspond exactly to your system's setup.  If this is the case,
you should edit the platform-dependent file as needed.

The rest of this section is a brief tutorial on creating or editing the
platform-dependent file.  It is mostly copied from the corresponding lcc
documentation.

You can debug your version of the driver by running it with the -v -v options,
which cause it to echo the commands it would execute, but not to execute them.

Here is an example platform-dependent file, mips-ultrix.c:

/* DECstations running Ultrix */
#include <string.h>

char *cpp[] = { _TICKC_CPP,
		  "-DLANGUAGE_C", "-D__LANGUAGE_C",  "-D__LANGUAGE_C__", 
		  "-Dunix", "-D__unix", "-D__unix__", 
		  "-Dultrix", "-D__ultrix", "-D__ultrix__", 
		  "-Dbsd4_2", "-D__bsd4_2", "-D__bsd4_2__", 
		  "-Dmips=1", "-D__mips=1", "-D__mips__=1", 
		  "-Dhost_mips", "-D__host_mips", "-D__host_mips__",
		  "-DMIPSEL", "-D__MIPSEL", "-D__MIPSEL__", 
		  "$1", "$2", "$3", 0 };

char *include[] = { "-I/usr/include", 0 };

char *com[] = { _TICKC_COM, "-target=mips-ultrix",
	"$1", "$2", "$3", 0 };

char *as[] =  { _TICKC_AS, "-o", "$3", "", "$1",
        "-nocpp", "-EL", "$2", 0 };

char *ld[] =  { _TICKC_LD, "-o", "$3", "/usr/lib/crt0.o", "$1", 
		"-L"_TICKC_LIB, 
		"$2", "-ltickc-rts", "-lvcode", "-lc", 0 };

int option(arg) char *arg; {
	if (strcmp(arg, "-g") == 0)
		ld[15] = "-lg";
	else if (strcmp(arg, "-p") == 0) {
		ld[9]  = "/usr/lib/mcrt0.o";
		ld[16] = "-lc_p";
	} else if (strcmp(arg, "-pg") == 0) {
		ld[9]  = "/usr/lib/gcrt0.o";
		ld[16] = "-lc_p";
	} else if (strcmp(arg, "-b") == 0
		   && access(_TICKC_BBX, 4) == 0)
	  ld[13] = _TICKC_BBX;
	else
	  return 0;
	return 1;
}

Most of the host-specific code is data that gives prototypes for the
commands that invoke the preprocessor, compiler, assembler, and loader.
Each command prototype is an array of pointers to strings terminated with a
null pointer; the first string is the full path name of the command and the
others are the arguments or argument placeholders, which are described
below.

The cpp array specifies the command for running the preprocessor, which should
be the GNU C preprocessor.

Literal arguments specified in prototypes, e.g., "-Dmips=1" in the cpp
command above, are passed to the command as given.

The strings "$1", "$2", and "$3" in prototypes are placeholders for lists of
arguments that are substituted in a copy of the prototype before the
command is executed. $1 is replaced by the options specified by the user;
for the preprocessor, this list always contains at least -Dunix and 
-D__TCC__. $2 is replaced by the input files, and $3 is replaced by the 
output file.

Zero-length arguments after replacement are removed from the argument list
before the command is invoked. So, e.g., if the preprocessor is invoked
without an output file, "$3" becomes "", which is removed from the final
argument list.

The tokens beginning with '_TICKC' are preprocessor macros whose values are
determined by the installation procedure in Step 2.1.  Look in
$install/Makefile.in to see how they are defined.  They should at least spare
you the trouble of manually specifying the locations and names of executables
invoked by the compiler driver.

The include array is a list of -I options that specify which directives
should be searched to satisfy include directives. These directories are
searched in the order given.

Design this list carefully. Mixing ANSI and pre-ANSI headers may mix
incompatible headers. Unless the default list holds only /usr/include or only
the ANSI headers, many users may be forced to use -N and -I incessantly.

com gives the command for invoking the compiler.  On a DECstation, this
prototype can appear as shown above.  The -target option specifies the default
output target (either 'sparc-sun' or 'mips-ultrix').

as gives the command for invoking the assembler.

ld gives the command for invoking the loader. For the other commands, the list
$2 contains a single file; for ld, $2 contains all '.o' files and libraries,
and $3 is a.out, unless the -o option is specified. As suggested in the code
above, ld must also specify the appropriate startup code and default libraries.

The option function is called for the options -g, -p, -pg, and -b because these
compiler options might also affect the loader's arguments. For these options,
the driver calls option(arg) to give the host-specific code an opportunity to
edit the ld command, if necessary. option can change ld, if necessary, and
return 1 to announce its acceptance of the option. If the option is
unsupported, option should return 0.

For example, in response to -g, the option function shown above changes ld[15]
from '' to '-g'.  If -g is not specified, the '' argument is omitted from the
as command because it's empty.

Likewise, the -p causes option to change the name of the startup code and add
the name of the profiling library.

On Suns, the driver also recognizes -Bstatic and -Bdynamic as linker options,
and recognizes but ignores Sun's ``-target name'' option.

The option -Woarg causes the driver to pass arg to option. Such options have no
other effect; this mechanism is provided to support system-specific options
that affect the commands executed by the driver.

To complete the driver, write an appropriate option function for your
system, and make and install the driver as described above.

2.3 Important note for Solaris users
------------------------------------

The dynamic code disassembler on Solaris requires parts of the GNU binutils.
In particular, you need to build the binutiles libraries libopcodes.a and
libbfd.a and install them in $libdir.

The alternative is to do without dynamic code disassembly.  This is probably
not a good idea, but you can do it as follows:
1. comment out the line 
             "-lopcodes", "-lbfd",
in the file $srcdir/config/sys/sparc-solaris.c
2. comment out all the code in the function v_dump in the file
$srcdir/src/vcode/sparc-dis.c

2.4 Compiling with optimizations
--------------------------------

By default, the top-level makefile (created from $install/Makefile.in) is set
up for compiling with low optimizations and debugging on.  This decreases
compiler compile time and improves debugging, but decreases the performance of
the dynamic compiler (vcode, icode, etc.).

To increase the performance of the dynamic compiler, change the line
MODE	=	debug
to read
MODE	=	optimize


3 Using tcc with SimpleScalar
-----------------------------

tcc can be used with the SimpleScalar simulation environment
(http://www.cs.wisc.edu/~mscalar/simplescalar.html).

To set up tcc as a cross-compiler for SimpleScalar, type:
	% ./configure --target=ss{big,little}-na-sstrix
		(depending on whether your host is big- or little-endian)
	% gmake

Make will halt, issuing a message that you should edit some lines in the
makefile.  Edit the makefile as directed, then invoke make again.
