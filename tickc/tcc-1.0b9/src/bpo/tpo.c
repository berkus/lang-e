/* $Id: tpo.c,v 1.2 1997/12/11 01:26:17 maxp Exp $ */

#include <assert.h>
#include <ctype.h>
#include <stdio.h>
#include "bpo.h"
#include "list.h"
#include "mem.h"
#include "string.h"
#include "tpo.h"

#if !defined(__GNUC__) || defined(__STRICT_ANSI__)
#define inline
#endif

#if defined(__sparc__) && !defined(__LCC__) && !defined(__SVR4)
extern int fprintf (FILE *, char *, ...);
extern int printf (char *, ...);
extern int tolower (int);
#endif

#ifdef NDEBUG
#define DEBUG(x)
#else
#define DEBUG(x) x
#endif
#define PDEBUG(x)  DEBUG(if (debug) printf x;)
#define PDEBUG2(x) DEBUG(if (debug>1) printf x;)

#define PSZ 16			/* Max rewrite buf size (mult of input len) */
#define BSZ 512			/* Binary optimization temporary buffer size */
#define LSZ 256			/* Maximum input line size */
#define HSZ 107			/* Hash table size */
#define VSZ 64			/* Max number of vars instances in a pattern */
#define MNP 16384		/* Max number of patterns */

typedef struct lt {		/* Line object, for patternizing on rules */
     char *t;
     struct lt *p;
     struct lt *n;
} line_t;

static int debug, ntry;

extern void exit(int);
static void error (char *msg) {
     fprintf(stderr, "tpo: %s\n", msg);
     exit(1);
}

/* install: install str in string table -- mostly snarfed from copt */
static char *install (char *str) {
     register struct hnode *p;
     register char *p1, *p2, *s;
     register int i;
     static struct hnode {
	  char *s;
	  struct hnode *p;		  
     } *htab[HSZ] = {0};
	
     s = str;
     for (i = 0; *s; i += *s++) ;
     i %= HSZ;

     for (p = htab[i]; p; p = p->p) 
	  for (p1=str, p2=p->s; *p1++ == *p2++; )
	       if (p1[-1] == '\0')
		    return (p->s);
     NEW(p, 1, ARENA0);
     NEW(p->s, s-str+1, ARENA0);
     strcpy(p->s, str);
     p->p = htab[i];
     htab[i] = p;
     assert((int)p->s > MNP);	/* Distinguish pattern table entries */
     return p->s;
}

/*
 * Misc line/list operations
 */

/* connect: connect lines a and b */
inline static void connect (line_t *a, line_t *b) { 
     assert(a && b); 
     a->n = b; b->p = a; 
}

/* insert: insert a new line with text s before line p */
inline static void insert (char *s, line_t *p) {
     line_t *n;

     NEW(n, 1, ARENA0);
     n->t = s;
     connect(p->p, n);
     connect(n, p);
}

/* bufput: print p (up to \0) to buffer b having limit l */
inline static char *bufput (char *p, char *b, char *l) {
     while (*p && b < l) *b++ = *p++;
     if (*p) error("Insufficient space in output buffer");
     return b;
}

/* bufget: fill line lp (having limit ll) with data from bp, up to
   but not including '\n', and terminate it with \0 */
inline static char *bufget (char *lp, char *ll, char *bp) {
     while (*bp && *bp != '\n' && lp < ll) *lp++ = *bp++;
     *lp = '\0'; 
     if (*bp == '\n') bp++;
     return bp;
}

/* buf2list: read lines from buffer ibuf, creating a list of line_t's */
static void buf2list (char *ibuf, line_t *h, line_t *t) {
     char l[LSZ], *ip = ibuf, *ll = l+LSZ-1;

     connect(h, t); 
     h->p = 0L; t->n = 0L; h->t = t->t = "";
     while (*ip) {
	  ip = bufget(l, ll, ip);
	  insert(install(l), t);
     }
}

/* list2buf: unparse the list of lines l into buf obuf having limit olim */
static void list2buf (line_t *l, char *obuf, char *olim) {
     while (l) {
	  if (l->t) {
	       obuf = bufput(l->t, obuf, olim-1);
	       *obuf++ = '\n';
	  }
	  l = l->n;
     }
     assert(obuf < olim); *obuf = '\0';
}

/*
 * Matching/patternizing
 */

static char *vlist[VSZ];

/* tlinematch: returns 1 if pattern p matches input i, 0 otherwise. If pattern
   matches, sets variables appropriately.  If there is a match, v is the
   number of variables matched. */
inline static int tlinematch (char *i, char *p, unsigned int *v) {
     char c1, c2, *q, lin[LSZ];
     int c; unsigned int nv = 0;

     PDEBUG2(("tlinematch: p=%s\n", p));
     while (*i && *p)
	  if (*p == '%') {
	       c1 = tolower(p[1]);
	       if (c1 >= 'a' && c1 <= 'z') {
		    c = c1-'a';
		    for (c2 = p[2], q = lin; *i && *i != c2; *q++ = *i++)
			 assert(q - lin < LSZ-1);
		    *q = 0; q = install(lin);
		    if (bpoV[c].ver == ntry) {
			 if (bpoV[c].val != (T)q) return 0L;
		    } else {
			 assert(bpoV[c].ver < ntry);
			 bpoV[c].ver = ntry;
			 bpoV[c].val = (T)q;
		    }
		    nv++; p += 2;
	       } else if (c1 == ' ') {
		    for (c2 = p[2], q = lin; *i && *i != c2; *q++ = *i++)
			 assert(q - lin < LSZ-1);
		    *q = 0; vlist[nv++] = install(lin);
		    p += 2;
	       } else if (c1 == '%') {
		    if (c1 != *i++) return 0;
		    p += 2;
	       } else assert(0); /* Bad pattern generated by tog */
	  } else if (*p++ != *i++)
	       return 0;
     *v = nv;
     return *p==*i;
}

/* trulematch: if text rule r matches the lines beginning at l, returns the
   line immediately prior to the end point of the match, 
   otherwise returns 0L. */
static line_t *trulematch (line_t *l, trule_t *r) {
     int i; unsigned int v;
     for (i = r->ni-1; i >= 0; --i, l = l->p) {
	  if (!l || !l->t) return 0L;
	  if (!tlinematch(l->t, r->ins[i], &v)) return 0L;
     }
     return l;
}

/* buf2pats: patternizes the text in buffer ibuf.  Returns a list of
   pattern ids and pointers to variable strings. */
static List buf2pats (char *ibuf) {
     unsigned int i, j, k;
     char l[LSZ], *ll=l+LSZ-1, *ip = ibuf;
     List olst = 0L;

     while (*ip) {
	  ip = bufget(l, ll, ip);
	  for (i = 0; i < tpoNP; i++)
	       if ((tlinematch(l, tpoP[i], &k))) {
		    olst = l_append((void*)i, olst, ARENA0);
		    PDEBUG2(("\tfile2pats: string %d\n", i));
		    for (j = 0; j < k; j++) {
			 olst = l_append((void*)vlist[j], olst, ARENA0);
			 PDEBUG2(("\tfile2pats: value 0x%p\n", vlist[j]));
		    }
		    break;
	       }
	  if (i == tpoNP) { /* Did not find a match above */
	       PDEBUG2(("\tPatternize: mismatch %s\n", l));
	       olst = l_append((void*)install(l), olst, ARENA0);
	  }
     }
     return olst;
}

/*
 * Unpatternizing/unparsing
 */

/* bin2text: return the string created by applying the format string referenced
   by LOAD(*p) to the patternized pointers following it, up to at most l */
inline static char *bin2text (W *p, W l) {
     char b[LSZ], *c = b, c1, *q1, *q2;
     assert(!GT(*p, l));	/* *p must point to a pattern format string */
     assert((unsigned long)LOAD(*p) < tpoNP);
     q1 = tpoP[(unsigned long)LOAD(*p)];
     assert(q1);		/* q1 is now the string pointer in *p */
     PDEBUG2(("bin2text0: '%s'\n", q1));
     while (*q1) {
	  assert(c-b < LSZ);
	  if (*q1 == '%') {
	       c1 = tolower(q1[1]);
	       if ((c1 >= 'a' && c1 <= 'z') || c1 == ' ') {
		    INCR(*p); assert(!GT(*p, l));
		    q2 = (char *)LOAD(*p);
		    PDEBUG2(("bin2text1: %s\n", q2));
		    while (*q2) { assert(c-b < LSZ); *c++ = *q2++; }
	       } else {
		    assert(c1 == '%'); /* tog checks this */
		    *c++ = c1;
	       }
	       q1 += 2;
	  } else
	       *c++ = *q1++;
     }
     *c = '\0'; INCR(*p);
     return install(b);
}

/* bin2list: insert the (binary-represented) code between p and lim (inclusive)
   int the text code list before l */
inline static void bin2list (line_t *l, W p, W lim) {
     while (p <= lim) insert(bin2text(&p, lim), l);
}

/* pats2buf: decode the contents of ibuf (patternized data), up to lim, and
   dump the output to obuf (which has limit olim). */
static void pats2buf (W ibuf, W lim, char *obuf, char *olim) {
     while (ibuf < lim) {
	  assert((unsigned long)LOAD(ibuf) >= 0);
	  PDEBUG2(("pats2file: 0x%p\n", (void *)LOAD(ibuf)));
	  if ((unsigned long)*ibuf < tpoNP) { /* It is a pattern table entry */
	       obuf = bufput(bin2text(&ibuf, lim), obuf, olim-2);
	       *obuf++ = '\n';
	  } else {
	       obuf = bufput((char*)LOAD(ibuf), obuf, olim-2);
	       *obuf++ = '\n';
	       INCR(ibuf);
	  }
     }
     assert(obuf < olim); *obuf = '\0';
}

/*
 * Drivers
 */

/* topt: peephole optimize the lines of text starting at *lp */
static int topt (line_t **lp) {
     int i;
     line_t *l = *lp, *l2;
     T lim[BSZ]; 
     W p, buf = lim+BSZ-1;

     for (i = 0; i < bpoNR; i++) {
	  ++ntry;
	  if ((l2 = trulematch(l, tpoR+i))) {
	       connect(l2, l->n);
	       PDEBUG(("Matched rule %d\n", i));
	       p = brulerepl(bpoR+i, buf, lim);
	       if (p <= buf)	/* If there is something to replace */
		    bin2list(l2->n, p, buf);
	       *lp = l2->n;	/* Also analyze the new code we inserted */
	       return 1;
	  }
     }
     *lp = l->n;		/* No match; move on to the next line */
     return 0;
}

static W add1 (W p) { return p+1; }

void tpo (char *inbuf, char *outbuf, char *outlim, int rulep, int dp) {
     List l;
     int change = 0;
     debug = dp;
     ntry = 1;
     if (rulep) {		/* Patternize on entire rules */
	  line_t h, t, *p;
	  buf2list(inbuf, &h, &t);
	  bpoinit();
	  for (p = h.n; p != &t; change = topt(&p))
	       DEBUG(					\
		    if (debug && change) {		\
			 list2buf(h.n, outbuf, outlim);	\
			 fprintf(stderr, "%s", outbuf); \
		    }					\
		    );
	  list2buf(h.n, outbuf, outlim);
     } else if ((l = buf2pats(inbuf))) {
	  List lp = l;		/* Patternize on single patterns */
	  int ll = l_length(l);
	  W p, cbuf, obuf, tbuf, olim;

	  NEW(obuf, PSZ*ll, ARENA0);
	  NEW(tbuf, PSZ*ll, ARENA0);
	  p = cbuf = tbuf+(PSZ-1)*ll;
	  
	  do { lp = lp->link; *p++ = (T)lp->x; } while (lp != l);
	  STORE(p, (T)0);

	  olim = bpo(cbuf, cbuf+ll, tbuf, obuf, obuf, obuf+9*ll, 
		     add1, 
#ifndef __bpo_no_relo__
		     0L, 0L,
#endif
		     dp);

	  pats2buf(obuf, olim, outbuf, outlim);
     }
}
