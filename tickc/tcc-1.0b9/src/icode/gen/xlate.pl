#!perl

# $Id: xlate.pl,v 1.6 1998/05/17 20:38:42 maxp Exp $

				# 
				# Parse command line arguments
				# 
use Getopt::Long;
$specfile = "";
&GetOptions("spec=s", \$specfile);

$usage = <<EOF
Usage: $0 [-spec spec-file] out-file [ obj-file-1 ... obj-file-n ]

      * out-file is the code-generating file to create.
      * obj-file-x specifies a file to be searched for icode macros.
      * -spec can be used to specify a file containing icode macros for which
	to create code generators.  The macros should appear one per line.
      * An example:
	% cat > foo
	addi
	addii
	retv
	^D
	% $0 -spec foo xlate.c a.out
	This will create a file called xlate.c containing code generators for
	all the macros specified in foo (addi, addii, retv) and any macros
	used in a.out.
      * Specifying neither spec-file nor obj-file produces an empty translator.

EOF
    ;

if ($#ARGV < 0) { die $usage; }
$outfile = shift;
				# 
				# Parse icode op.def file
				# 
sub enroll {
    local($t, $op) = @_;
    my $k;
    $k->{opname} = "$opname$t";
    $k->{opcode} = $op;
    push @allops, $k;
}
sub readopdef {
    unless (open OPDEF, "< __OPDEF__") { die "Can't open __OPDEF__\n"; }
    while (<OPDEF>) {
	/^;/ && next;
	if ( /^\(misc (\w+)/ ) {
	    $opname = $1;
	    &enroll("",  $opcode++);
	    $opcode2components{"$opname$ty"} = "f_misc:$opname.";
	} elsif ( /^\(format(i?) (\w+) (\([\w\s]+\))/ ) {
				# match "(format <format name> (<args>))"
	    $imm = $1;
	    $fname = $2;
	} elsif ( /^\((\w+)\s*\(([\w\s\(\)]+)\)\)\s*$/ ) {
				# match "(opcode (types (types-in-paren) ...))"
				# types-in-paren do not have immediate ops,
				# others do.
	    !$fname && die("syntax error\n");
	    $opname = $1; $_ = $2;
	    if ($2) {
		do {
		    s/(.*)(\(.+\))(.+)/\1\3\2/g;
		} until /^[^\(\)]*(\([^\(\)]*\))*$/;
	    }
				# put into canonical form: t1:t2:..:tn|u1:..:un
				# where u* are types-in-paren and t* are not
	    s/\s+/:/g; s/[\(\)]/\|/g; s/\|\|/:/g; s/(:\||\|:)/\|/g; s/^://g;
	    $phase = 0;		# phase==0: std ops; phase==1: nonimmediate ops
	    foreach $xty (split /\|/, $_) {
		foreach $ty (split /:/, $xty) {
		    $opcode2components{"$opname$ty"} = "$fname:$opname.$ty";
		    &enroll("$ty", $opcode);
		    if (!$imm && !$phase) {
			$opcode2components{"$opname${ty}i"} = 
			    "${fname}i:$opname.${ty}i";
			$immop = $opcode+512;
			&enroll("${ty}i", $immop);
			if ($immop > $maxop) { $maxop = $immop; }
		    }
		    $opcode++;
		}
		++$phase;
	    }
	}
    }
    close(OPDEF);
    @allops = sort { $a->{opcode} <=> $b->{opcode} } @allops;
}
				# 
				# Find icode symbols that need to be generated
				# 
sub findsyms {
    my ($nsyms, $op);
    $nsyms = 0;
    if ($specfile ne "") {
	unless (open SPEC, "< $specfile") { die "Can't open $specfile\n"; }
	while (<SPEC>) { 
	    $op = $_;
	    chomp $op;
	    unless (defined $opcode2components{$op}) { 
		die "Undefined opcode $op in $specfile\n";
	    }
	    $nsyms++; $neededops{$op} = "x"; 
	}
	close SPEC;
    }
    $neededops{"refdiv"} = 1;
    $neededops{"refmul"} = 1;
    $neededops{"self"} = 1;
    $neededops{"lbl"} = 1;
    $neededops{"nop"} = 1;
    $neededops{"retv"} = 1;
    foreach $file (@ARGV) {
	if (! ($file =~ /.*\.o/)) { next; }
	unless (open NM, "__NM__ $file |") { die "Can't open $file\n"; }
	while (<NM>) {
	    if (/_tciu_i_(.*)/) { 
		$op = $1;
		unless (defined $opcode2components{$op}) { 
		    die "Undefined opcode $op in $file\n";
		}
		$nsyms++; $neededops{$op} = 1; 
	    }
	}
	close NM;
    }
    return $nsyms;
}
				# 
				# Emit header of xlate.c
				# 
sub gen_header {
    print <<EOF
/* 
   This file is an icode code generator automatically generated by $0.
   Do not edit by hand.
*/
#include <icode.h>
#include <icode-internal.h>

#define i2vreg(i) ((v_reg_type)(i))
static inline v_reg_type i_find (v_reg_type t, i_local_t l) {
     switch (SCLASS(l)) {
     case REGISTER:	return i2vreg(ADDR(l));
     case STACK: 
     case DATA:		return t;
     case UNDECIDED:			
	  printf("warning: dead code; i_find uses null register\\n");
	  return 0;
     default:		assert(0); return 0;
     }
}

/* i_load: ensures that l is in a register storage location (see also i_find).
   If l is stored in a register, returns that register.
   If l is in memory, loads l into temp register t and returns t. */
static v_reg_type i_load (v_reg_type t, i_local_t l, unsigned char ty) {
     v_reg_type base;							
									
     switch (SCLASS(l)) {						
     case REGISTER:	return i2vreg(ADDR(l));
     case STACK:	base = v_lp; break;
     case DATA:		base = v_zero; break;
     default: 		assert(0); return 0;
     }									
     switch (ty) {							
     case I_C: v_ldci(t, base, ADDR(l)); break;				
     case I_UC: v_lduci(t, base, ADDR(l)); break;			
     case I_S: v_ldsi(t, base, ADDR(l)); break;				
     case I_US: v_ldusi(t, base, ADDR(l)); break;			
     case I_I: v_ldii(t, base, ADDR(l)); break;				
     case I_U: v_ldui(t, base, ADDR(l)); break;				
     case I_L: v_ldli(t, base, ADDR(l)); break;				
     case I_UL: v_lduli(t, base, ADDR(l)); break;			
     case I_P: v_ldpi(t, base, ADDR(l)); break;				
     case I_F: v_ldfi(t, base, ADDR(l)); break;				
     case I_D: v_lddi(t, base, ADDR(l)); break;				
     default: assert(0);						
     }									
     return t;								
}

/* i_store: make sure that the contents of t is stored in location for local l.
   If l lives in a register, does nothing.
   If l does not live in a register, stores t into the location of l. */
static void i_store (v_reg_type t, i_local_t l, unsigned char ty) {
     v_reg_type base;

     switch (SCLASS(l)) {						
     case REGISTER:
	  if (ADDR(l) != t) {
	       switch (ty) {
	       case I_C: case I_S: case I_I:
		    v_movi(ADDR(l), t); break;
	       case I_UC: case I_US: case I_U:
		    v_movu(ADDR(l), t); break;
	       case I_L: v_movl(ADDR(l), t); break;
	       case I_UL: v_movul(ADDR(l), t); break;
	       case I_P: v_movp(ADDR(l), t); break;
	       case I_F: v_movf(ADDR(l), t); break;
	       case I_D: v_movd(ADDR(l), t); break;
	       default: assert(0);
	       }
	  }
	  return;
     case STACK:	base = v_lp; break;
     case DATA:		base = v_zero; break;
     case UNDECIDED:							
	  printf("warning: dead code; i_store uses null register\\n");	
	  return;							
     default: assert(0); return;					
     }									
     switch (ty) {							
     case I_C: v_stci(t, base, ADDR(l)); break;				
     case I_UC: v_stuci(t, base, ADDR(l)); break;			
     case I_S: v_stsi(t, base, ADDR(l)); break;				
     case I_US: v_stusi(t, base, ADDR(l)); break;			
     case I_I: v_stii(t, base, ADDR(l)); break;				
     case I_U: v_stui(t, base, ADDR(l)); break;				
     case I_L: v_stli(t, base, ADDR(l)); break;				
     case I_UL: v_stuli(t, base, ADDR(l)); break;			
     case I_P: v_stpi(t, base, ADDR(l)); break;				
     case I_F: v_stfi(t, base, ADDR(l)); break;				
     case I_D: v_stdi(t, base, ADDR(l)); break;				
     default: assert(0);						
     }									
}

#define assign2(v, f, p1, p2) { v = f(p1,p2); }
#define assign3(v, f, p1, p2, p3) { v = f(p1,p2,p3); }

/* Auxiliary code for calls, caller-saved register save/restores, etc */

static unsigned int vpushinit = 0; /* True if call context has been set up */
static struct v_cstate vcs;	/* Call context */
static i_puint32 xlp;

typedef struct {
     i_local_t loc;
     int reg;
} save;
static save saves[num_ireg], fsaves[num_freg];
static unsigned int nsaves, nfsaves;
enum { NORESTORE=0, RESTORE=1 };
static bvt icallersave, fcallersave;
static bvt isav, fsav;
static i_bb_t cbb;		/* Current basic block */

static inline void doisave (unsigned int l, bvt bv, void *v) {
     unsigned int rf = (unsigned int)v;
     if (SCLASS(l) == REGISTER && bv_setp(icallersave, ADDR(l))) {
	  int addr; int reg;
          if (rf == RESTORE) {
		save *s = saves+nsaves++;
	        assert(nsaves <= num_ireg);
                s->loc = l; reg = s->reg = ADDR(l);
	  } else 
		reg = ADDR(l);
	  SCLASS(l) = STACK; addr = ADDR(l) = v_local(TYPE(l));
	  switch (TYPE(l)) {				
	  case I_C: v_stci(reg, v_lp, addr); break;
	  case I_UC: v_stuci(reg, v_lp, addr); break;
	  case I_S: v_stsi(reg, v_lp, addr); break;
	  case I_US: v_stusi(reg, v_lp, addr); break;
	  case I_I: v_stii(reg, v_lp, addr); break;
	  case I_U: v_stui(reg, v_lp, addr); break;
	  case I_L: v_stli(reg, v_lp, addr); break;
	  case I_UL: v_stuli(reg, v_lp, addr); break;
	  case I_P: v_stpi(reg, v_lp, addr); break;
	  default: assert(0);
	  }
     }
}
static inline void dofsave (unsigned int l, bvt bv, void *v) {
     unsigned int rf = (unsigned int)v;
     l = fp_mk(l);		/* bit vector id -> fp variable handle */
     if (SCLASS(l) == REGISTER && bv_setp(fcallersave, ADDR(l))) {
	  int addr; int reg;
          if (rf == RESTORE) {
		save *s = fsaves+nfsaves++;
	        assert(nfsaves <= num_freg);
                s->loc = l; reg = s->reg = ADDR(l);
	  } else 
		reg = ADDR(l);
	  SCLASS(l) = STACK; addr = ADDR(l) = v_local(TYPE(l));
	  switch (TYPE(l)) {
	  case I_F: v_stfi(reg, v_lp, addr); break;
	  case I_D: v_stdi(reg, v_lp, addr); break;
	  default: assert(0);
	  }
     }
}
static inline void dorestore () {
     int i;
     i_local_t l;
     for (i=0; i<nsaves; i++) {
    	  save *s = saves+i;
	  l = s->loc;
	  switch(TYPE(l)) {
	  case I_C: v_ldci(s->reg, v_lp, ADDR(l)); break;
	  case I_UC: v_lduci(s->reg, v_lp, ADDR(l)); break;
	  case I_S: v_ldsi(s->reg, v_lp, ADDR(l)); break;
	  case I_US: v_ldusi(s->reg, v_lp, ADDR(l)); break;
	  case I_I: v_ldii(s->reg, v_lp, ADDR(l)); break;
	  case I_U: v_ldui(s->reg, v_lp, ADDR(l)); break;
	  case I_L: v_ldli(s->reg, v_lp, ADDR(l)); break;
	  case I_UL: v_lduli(s->reg, v_lp, ADDR(l)); break;
	  case I_P: v_ldpi(s->reg, v_lp, ADDR(l)); break;
	  default: assert(0);
	  }
	  SCLASS(l) = REGISTER; ADDR(l) = s->reg;
     }
     for (i=0; i<nfsaves; i++) {
    	  save *s = fsaves+i;
	  l = s->loc;
	  switch(TYPE(l)) {
	  case I_F: v_ldfi(s->reg, v_lp, ADDR(l)); break;
	  case I_D: v_lddi(s->reg, v_lp, ADDR(l)); break;
	  default: assert(0);
	  }
	  SCLASS(l) = REGISTER; ADDR(l) = s->reg;
     }
     nsaves = nfsaves = 0;
}

static bvt lscsav (int sc, i_cnt_t scn) {
     i_local_t i;
     i_lr_t lrs;
     i_cnt_t base, lim;
     bvt v;
     if (sc == FP) {
	  lrs = i_flrs;
	  base = i_flr_cur+1;
	  lim = num_f;
     } else {
	  lrs = i_ilrs;
	  base = i_ilr_cur+1;
	  lim = num_i;
     }
     v = bv_new(lim);
     for (i = base; i < lim; i++)
	  if (lrs[i].beg <= scn && lrs[i].end >= scn)
	       bv_set(v, lrs[i].n);
     return v;
}

static void callinit (icode_t cp) {
    icode_t ccp = cp;
    i_local_t arg;
    bvt iargs, fargs;

    if (num_i) { iargs = bv_new(num_i); }
    if (num_f) { fargs = bv_new(num_f); }

    do {
	 switch (get_op(ccp)) {
 	 case i_op_argi:	case i_op_argu:
	 case i_op_argl:	case i_op_argul:
	 case i_op_argp:
	      arg = get_rd(ccp);
	      if (SCLASS(arg) == REGISTER && bv_setp(icallersave, ADDR(arg)))
		   bv_set(iargs, arg);
	      break;
	 case i_op_argf:	case i_op_argd:
	      arg = get_rd(ccp);
	      if (SCLASS(arg) == REGISTER && bv_setp(fcallersave, ADDR(arg)))
		   bv_set(fargs, fp_id(arg));
	      break;
	 case i_op_callv:	case i_op_callvi:
	 case i_op_calli:	case i_op_callii:
	 case i_op_callu:	case i_op_callui:
	 case i_op_calll:	case i_op_callli:
	 case i_op_callul:	case i_op_calluli:
	 case i_op_callp:	case i_op_callpi:
	 case i_op_callf:	case i_op_callfi:
	 case i_op_calld:	case i_op_calldi:
	      if (num_i) {
		   isav = (i_ralloctype == RA_LS) ? 
			lscsav(INT, cbb->scn) : get_isav(ccp);
		   if (isav) {
		       bv_eachbit(isav, doisave, (void *)RESTORE);
		       bv_eachbit(bv_rdiff(iargs, isav), 
				  doisave, (void *)NORESTORE);
		   } else {
		       bv_eachbit(iargs, doisave, (void *)NORESTORE);
		   }
	      }
	      if (num_f) {
		   fsav = (i_ralloctype == RA_LS) ? 
			lscsav(FP, cbb->scn) : get_fsav(ccp);
		   if (fsav) {
		       bv_eachbit(fsav, dofsave, (void *)RESTORE);
		       bv_eachbit(bv_rdiff(fargs, fsav), 
				  dofsave, (void *)NORESTORE);
		   } else {
		       bv_eachbit(fargs, dofsave, (void *)NORESTORE);
		   }
	      }
	      v_push_init(&vcs);
	      return;
	 default:
	 }
    } while ((ccp += i_isize) < xlp);
}

static i_puint32 i_x_retv(i_puint32 cp) {
     v_retv();
     return cp+i_isize;
}
i_puint32 i_x_callv (i_puint32 cp) {
     v_reg_type tr0;		/* Dummy registers */
     if (!vpushinit) { callinit(cp); }
     assign3(tr0, i_load, t0, get_rs(cp), I_P);
     v_rccallv(&vcs, tr0);
     dorestore();
     vpushinit = 0;
     return cp+2*i_isize;
}
static i_puint32 i_x_callvi (i_puint32 cp) {
     if (!vpushinit) { callinit(cp); }
     v_ccallv(&vcs, (v_vptr)get_imm(cp));
     dorestore();
     vpushinit = 0;
     return cp+2*i_isize;
}
static i_puint32 i_x_jp (i_puint32 cp) {
     i_local_t x0 = get_rd(cp);		/* Dummy locals */
     v_reg_type tr1;		/* Dummy registers */
     assign3(tr1, i_load, t1, x0, I_P);
     v_jp(tr1);
     return cp+i_isize; 
}
static i_puint32 i_x_jpi (i_puint32 cp) {
     v_jv(get_imm(cp));
     return cp+i_isize; 
}
static i_puint32 i_x_lbl (i_puint32 cp) {
     i_local_t x0 = get_rd(cp);		/* Dummy locals */
     v_label(x0);
     return cp+i_isize; 
}

static i_puint32 codeptr;
static i_puint32 i_x_self (i_puint32 cp) {
     i_local_t x0 = get_rd(cp);		/* Dummy locals */
     v_reg_type tr0;		/* Dummy registers */
     assign2(tr0, i_find, t0, x0);
     v_setp(tr0, codeptr);
     i_store(tr0, x0, I_P);
     return cp+i_isize;
}
static i_puint32 i_x_refmul (i_puint32 cp) { return cp+i_isize; }
static i_puint32 i_x_refdiv (i_puint32 cp) { return cp+i_isize; }
static i_puint32 i_x_nop (i_puint32 cp) { return cp+i_isize; }
static i_puint32 i_x_unspecified (i_puint32 cp) {
     fprintf(stderr, "Fatal icode error: encountered unexpected opcode:\\n");
     i_unparseinsn(stderr, cp);
     fprintf(stderr, 
	     "This error may be due to incorrect input to $0 \\n"
	     "at icode code generator generation time.\\n"
	     "Ensure that the above opcode is specified to $0.\\n");
     exit(-1);
}
static i_puint32 i_x_undefined (i_puint32 cp) {
     fprintf(stderr, 
	     "Fatal icode error: undefined opcode in translation.\\n"
	     "This should not happen.  Please send a bug report \\n"
	     "to maxp\@lcs.mit.edu.\\n");
     exit(-1);
}

EOF
    ;
}
				# 
				# Emit individual code gen routines
				# 
sub gen_xlators {
    foreach $op (sort keys(%neededops)) {
	unless (defined $opcode2components{$op}) { die "Fatal error\n"; }
	$opcode2components{$op} =~ /(.*):(.*)\.(.*)/;
	$kind = $1; $op = $2.$3;	
	if ($kind eq "f_misc") { next; }
	$t = $3; $t =~ s/(.)i$/\1/g;
	&printdef($kind, $op, $t);
    }
}

sub printdef {
    local($kind, $op, $t) = @_;
    %typemap = (
		"c", "I_C",
		"uc", "I_UC",
		"s", "I_S",
		"us", "I_US",
		"i", "I_I",
		"u", "I_U",
		"l", "I_L",
		"ul", "I_UL",
		"p", "I_P",
		"f", "I_F",
		"d", "I_D",
		"v", "I_V",
		);
				# ts is type suffix; mts is memop type suffix
    $ts = $typemap{$t}; $mts = $typemap{"p"};
    $f = ($t =~ /f|d/) ? "f" : "";

    $_ = $kind;
SW: {
				# F_BOPs
    /f_bopi/ && do {
	$_ = $op;
	/mulii/ && do {
	    print <<"EOF"
static i_puint32 i_x_$op (i_puint32 cp) {
     i_local_t x0 = get_rd(cp);	/* Dummy locals */
     v_reg_type tr0, tr1;	/* Dummy registers */
     assign2(tr0, i_find, t0, x0);
     assign3(tr1, i_load, t1, get_rs(cp), $ts);
     v_cmuli(tr0, tr1, get_imm(cp));
     i_store(tr0, x0, $ts);
     return cp+i_isize;
}
EOF
    ;
	    last SW;
	};
	/mului/ && do {
	    print <<"EOF"
static i_puint32 i_x_$op (i_puint32 cp) {
     i_local_t x0 = get_rd(cp);	/* Dummy locals */
     v_reg_type tr0, tr1;	/* Dummy registers */
     assign2(tr0, i_find, t0, x0);
     assign3(tr1, i_load, t1, get_rs(cp), $ts);
     v_cmulu(tr0, tr1, get_imm(cp));
     i_store(tr0, x0, $ts);
     return cp+i_isize;
}
EOF
    ;
	    last SW;
	};
	print <<"EOF"
static i_puint32 i_x_$op (i_puint32 cp) {
     i_local_t x0 = get_rd(cp);	/* Dummy locals */
     v_reg_type tr0, tr1;	/* Dummy registers */
     assign2(tr0, i_find, t0, x0);
     assign3(tr1, i_load, t1, get_rs(cp), $ts);
     v_$op(tr0, tr1, get_imm(cp));
     i_store(tr0, x0, $ts);
     return cp+i_isize;
}
EOF
    ;
	last SW;
    };
    /f_bop/ && do {
	print <<"EOF"
static i_puint32 i_x_$op (i_puint32 cp) {
     i_local_t x0 = get_rd(cp);	/* Dummy locals */
     v_reg_type tr0, tr1, tr2;	/* Dummy registers */
     assign2(tr0, i_find, ${f}t0, x0);
     assign3(tr1, i_load, ${f}t0, get_rs(cp), $ts);
     assign3(tr2, i_load, ${f}t1, get_rs2(cp), $ts);/*t2*/
     v_$op(tr0, tr1, tr2);
     i_store(tr0, x0, $ts);
     return cp+i_isize;
}
EOF
    ;
	last SW;
    };
				# F_UOPs
    /f_uopi/ && do {
	print <<"EOF"
static i_puint32 i_x_$op (i_puint32 cp) {
     i_local_t x0 = get_rd(cp);	/* Dummy locals */
     v_reg_type tr0;		/* Dummy registers */
     assign2(tr0, i_find, t0, x0);
     v_$op(tr0, get_imm(cp));
     i_store(tr0, x0, $ts);
     return cp+i_isize;
}
EOF
    ;
	last SW;
    };
    /f_uop/ && do {
	$_ = $op;
	/mov/ && do {		# All mov ops
	    $_ = $t;
	    if (/uc|us/) { $vop = "v_movu"; } 
	    elsif (/c|s/) { $vop = "v_movi"; }
	    else { $vop = "v_$op"; }
	    print <<"EOF"
static i_puint32 i_x_$op (i_puint32 cp) {
     i_local_t x0 = get_rd(cp), x1; /* Dummy locals */
     v_reg_type tr1;		/* Dummy registers */
     x1 = get_rs(cp);
     if (SCLASS(x0) & (DATA|STACK)) {
				/* moving reg or stack into stack */
	  assign3(tr1, i_load, ${f}t1, x1, $ts);
	  if (SCLASS(x0) == DATA)
	       v_st${t}i(tr1, v_zero, ADDR(x0));
	  else
	       v_st${t}i(tr1, v_lp, ADDR(x0));
     } else {
	  if (SCLASS(x1) & (DATA|STACK)) {
				/* moving stack into reg */
	       if (SCLASS(x1) == DATA)
		    v_ld${t}i(i2vreg(ADDR(x0)), v_zero, ADDR(x1));
	       else
		    v_ld${t}i(i2vreg(ADDR(x0)), v_lp, ADDR(x1));
	  } else {
				/* moving reg into reg */
	       $vop(i2vreg(ADDR(x0)), i2vreg(ADDR(x1)));
	  }
     }
     return cp+i_isize;
}
EOF
    ;
	    last SW;
	};			# End of all mov ops
	/cv(.*)2(.*)/ && do {	# All cvS2D ops
	    $S = $1; $D = $2; 
	    $Sf = ''; if ($S =~ /f|d/) { $Sf = 'f'; }
	    $Df = ''; if ($D =~ /f|d/) { $Df = 'f'; }
	    $D = $typemap{$D}; $S = $typemap{$S};
    print <<"EOF"
static i_puint32 i_x_$op (i_puint32 cp) {
     i_local_t x0 = get_rd(cp);	/* Dummy locals */
     v_reg_type tr0, tr1;	/* Dummy registers */
     assign2(tr0, i_find, ${Df}t0, x0);
     assign3(tr1, i_load, ${Sf}t1, get_rs(cp), $S);
     v_$op(tr0, tr1);
     i_store(tr0, x0, $D);
     return cp+i_isize;
}
EOF
    ;
	    last SW;
	};			# End of all cvS2D ops
	print <<"EOF"
static i_puint32 i_x_$op (i_puint32 cp) {
     i_local_t x0 = get_rd(cp);	/* Dummy locals */
     v_reg_type tr0, tr1;	/* Dummy registers */
     assign2(tr0, i_find, ${f}t0, x0);
     assign3(tr1, i_load, ${f}t1, get_rs(cp), $ts);
     v_$op(tr0, tr1);
     i_store(tr0, x0, $ts);
     return cp+i_isize;
}
EOF
    ;
	last SW;
    };				# End of all f_uops
				# F_SETs
    /f_set/ && do {
	$_ = $t;
	/^(d|f)$/ && do {
	    print <<"EOF"
static i_puint32 i_x_$op (i_puint32 cp) {
     i_local_t x0 = get_rd(cp);	/* Dummy locals */
     v_reg_type tr0;		/* Dummy registers */
     assign2(tr0, i_find, ft0, x0);
     v_$op(tr0, i_imm$t(get_imm(cp)));
     i_store(tr0, x0, $ts);
     return cp+i_isize;
}
EOF
    ;
	    last SW;
	};
	print <<"EOF"
static i_puint32 i_x_$op (i_puint32 cp) {
     i_local_t x0 = get_rd(cp);	/* Dummy locals */
     v_reg_type tr0;		/* Dummy registers */
     unsigned int c = get_imm(cp);
     if (c == 0 && (SCLASS(x0) & (STACK|DATA))) {
	  if (SCLASS(x0) == STACK)
	       v_st${t}i(v_zero, v_lp, ADDR(x0));
	  else	
	       v_st${t}i(v_zero, v_zero, ADDR(x0));
     } else {
	  assign2(tr0, i_find, t0, x0);
	  v_$op(tr0, c);
	  i_store(tr0, x0, $ts);
     }
     return cp+i_isize;
}
EOF
    ;
	last SW;
    };
				# F_MOPs
    /f_mopri/ && do {
	print <<"EOF"
static i_puint32 i_x_$op (i_puint32 cp) {
     i_local_t x0 = get_rd(cp), x1, x2;	/* Dummy locals */
     v_reg_type tr0, tr1;	/* Dummy registers */
     x1 = get_rs(cp);
     x2 = get_imm(cp);
     assign2(tr0, i_find, ${f}t0, x0);
     switch (x1) {
     case i_zero: v_$op(tr0, v_zero, x2); break;
     case i_lp: v_$op(tr0, v_lp, x2); break;
     default:
	  assign3(tr1, i_load, t1, x1, $mts);
	  v_$op(tr0, tr1, x2);
     }
     i_store(tr0, x0, $ts);
     return cp+i_isize;
}
EOF
    ;
	last SW;
    };
    /f_mopwi/ && do {
	print <<"EOF"
static i_puint32 i_x_$op (i_puint32 cp) {
     i_local_t x0 = get_rd(cp), x1, x2;	/* Dummy locals */
     v_reg_type tr0, tr1;	/* Dummy registers */
     x1 = get_imm(cp);
     x2 = get_rs(cp);
     assign3(tr0, i_load, ${f}t0, x0, $ts);
     switch (x2) {
     case i_zero: v_$op(tr0, v_zero, x1); break;
     case i_lp: v_$op(tr0, v_lp, x1); break;
     default:
	  assign3(tr1, i_load, t1, x2, $mts);
	  v_$op(tr0, tr1, x1);
     }
     return cp+i_isize;
}
EOF
    ;
	last SW;
    };
    /f_mopr/ && do {
	print <<"EOF"
static i_puint32 i_x_$op (i_puint32 cp) {
     i_local_t x0 = get_rd(cp), x1; /* Dummy locals */
     v_reg_type tr0, tr1, tr2;	/* Dummy registers */
     x1 = get_rs(cp);
     assign2(tr0, i_find, ${f}t0, x0);
     assign3(tr2, i_load, t0, get_rs2(cp), $mts);
     switch (x1) {
     case i_zero: v_$op(tr0, v_zero, tr2); break;
     case i_lp: v_$op(tr0, v_lp, tr2); break;
     default:
	  assign3(tr1, i_load, t1, x1, $mts);
	  v_$op(tr0, tr1, tr2);
     }
     i_store(tr0, x0, $ts);
     return cp+i_isize;
}
EOF
    ;
	last SW;
    };
    /f_mopw/ && do {
	print <<"EOF"
static i_puint32 i_x_$op (i_puint32 cp) {
     i_local_t x0 = get_rd(cp), x1; /* Dummy locals */
     v_reg_type tr0, tr1, tr2;	/* Dummy registers */
     x1 = get_rs(cp);
     assign3(tr0, i_load, ${f}t0, x0, $ts);
     assign3(tr2, i_load, t2, get_rs2(cp), $mts);
     switch (x1) {
     case i_zero: v_$op(tr0, v_zero, tr2); break;
     case i_lp: v_$op(tr0, v_lp, tr2); break;
     default:
	  assign3(tr1, i_load, t1, x1, $mts);
	  v_$op(tr0, tr1, tr2);
     }
     return cp+i_isize;
}
EOF
    ;
	last SW;
    };
				# F_BRs
    /f_bri/ && do {		# In switch
	print <<"EOF"
static i_puint32 i_x_$op (i_puint32 cp) {
     i_local_t x0 = get_rd(cp);	/* Dummy locals */
     v_reg_type tr0;		/* Dummy registers */
     assign3(tr0, i_load, t0, get_rs(cp), $ts);
     v_$op(tr0, get_imm(cp), x0);
     return cp+i_isize;
}
EOF
    ;
	last SW;
    };
    /f_br/ && do {
	print <<"EOF"
static i_puint32 i_x_$op (i_puint32 cp) {
     i_local_t x0 = get_rd(cp);	/* Dummy locals */
     v_reg_type tr0, tr1;	/* Dummy registers */
     assign3(tr0, i_load, ${f}t0, get_rs(cp), $ts);
     assign3(tr1, i_load, ${f}t1, get_rs2(cp), $ts);
     v_$op(tr0, tr1, x0);
     return cp+i_isize;
}
EOF
    ;
	last SW;
    };
				# F_RETs
    /f_reti/ && do {		# In switch
	$_ = $op;
	print <<"EOF"
static i_puint32 i_x_$op (i_puint32 cp) {
     v_$op(get_imm(cp));
     return cp+i_isize;
}
EOF
    ;
	last SW;
    };
    /f_ret/ && do {		# In switch
	$_ = $op;
	/retv/ && last SW;	# i_retv is a special case; handle it manually
	print <<"EOF"
static i_puint32 i_x_$op (i_puint32 cp) {
     i_local_t x0 = get_rd(cp);	/* Dummy locals */
     v_reg_type tr1;		/* Dummy registers */
     assign3(tr1, i_load, ${f}t1, x0, $ts);
     v_$op(tr1);
     return cp+i_isize;
}
EOF
    ;
	last SW;
    };
				# F_CALLs and F_ARGs
    /f_calli/ && do {		# In switch
	$_ = $op;
	/callv/ && last SW;	# i_callvi is a special case
	print <<"EOF"
static i_puint32 i_x_$op (i_puint32 cp) {
     i_local_t x0 = get_rd(cp);	/* Dummy locals */
     v_reg_type tr1;		/* Dummy registers */
     if (!vpushinit) { callinit(cp); }
     tr1 = v_ccall$t(&vcs, (v_${t}ptr)get_imm(cp));
     i_store(tr1, x0, $ts);
     dorestore();
     vpushinit = 0;
     return cp+2*i_isize;
}
EOF
    ;
	last SW;
    };
    /f_call/ && do {		# In switch
	$_ = $op;
	/callv/ && last SW;	# i_callv is a special case
	print <<"EOF"
static i_puint32 i_x_$op (i_puint32 cp) {
     i_local_t x0 = get_rd(cp);	/* Dummy locals */
     v_reg_type tr0, tr1;	/* Dummy registers */
     if (!vpushinit) { callinit(cp); }
     assign3(tr0, i_load, t0, get_rs(cp), $ts);
     tr1 = v_rccall$t(&vcs, tr0);
     i_store(tr1, x0, $ts);
     dorestore();
     vpushinit = 0;
     return cp+2*i_isize;
}
EOF
    ;
	last SW;
    };
    /f_arg/ && do {		# In switch
	print <<"EOF"
static i_puint32 i_x_$op (i_puint32 cp) {
     i_local_t x0 = get_rd(cp);	/* Dummy locals */
     v_reg_type tr0;		/* Dummy registers */
     if (!vpushinit) {
	  callinit(cp); 
	  vpushinit = 1; 
     }
     assign3(tr0, i_load, ${f}t0, x0, $ts);
     v_push_$op(&vcs, tr0);
     return cp+i_isize;
}
EOF
    ;
	last SW;
    };
				# F_LEA
    /f_lea/ && do {		# In switch
	print <<"EOF"
static i_puint32 i_x_$op (i_puint32 cp) {
     i_local_t x0 = get_rd(cp), x1; /* Dummy locals */
     v_reg_type tr0;		/* Dummy registers */
     x1 = get_rs(cp);
     assert(SCLASS(x1) == STACK);
     assign2(tr0, i_find, t0, x0);
     v_addpi(tr0, v_lp, ADDR(x1));
     i_store(tr0, x0, $mts); /* tr0 is always a pointer */
     return cp+i_isize;
}
EOF
    ;
    };
}				# sw
}
				# 
				# Emit code gen func table and driver
				# 
sub gen_footer {
    print <<EOF
/* Map of icode opcodes to corresponding code generators */
typedef i_puint32 (*xf_t)(i_puint32);
static xf_t i_op2xlate[] = {
EOF
    ;

    $j = 0;
    for $i (0..$maxop) {
	if ($allops[$j]->{opcode} == $i) {
	    $j++; $k = $allops[$j-1];
	    if ($neededops{$k->{opname}}) {
		print "\ti_x_$k->{opname}, /* $k->{opcode} = $k->{opname} */\n";
	    } else {
		print "\ti_x_unspecified, /* don't need $k->{opname} ".
		    "($k->{opcode}) */\n";
	    }
	} else {
	    print "\ti_x_undefined, /* no opcode $i */\n";
	}
    }

    print <<EOF
};

#define NELEMS(a) ((int)(sizeof (a)/sizeof ((a)[0])))

/* i_xlate: generate vcode from icode; requires that reg alloc be completed */
void i_xlate (v_code *self) {
     i_puint32 cp;
     i_uint32 op;
     xf_t f;			/* Translator function for each opcode */

     codeptr = (i_puint32)self;

     icallersave = bv_init(i_ireg_alltmp, num_ireg/(8*sizeof(bvdt)));
     fcallersave = bv_init(i_freg_alltmp, num_freg/(8*sizeof(bvdt)));

     for (cbb = i_fg_root; cbb; cbb = cbb->lnext) {
	  cp = cbb->h;
	  xlp = cbb->t + i_isize;
	  while (cp < xlp) {
	       if (i_debug) printf("icode:%p matches vcode:%p\\n", cp, v_ip);
	       op = get_op(cp);
	       assert(op < NELEMS(i_op2xlate));
	       f = i_op2xlate[op];
	       cp = f(cp);
	  }
     }

}
EOF
    ;
}
				# 
				# Main
				# 
@allops = (); $maxop = 0;
&readopdef();

unless (open OUTF, "> $outfile") { die "Can't open $outfile\n"; }
select OUTF;

if (&findsyms() == 0) {
    print "#include <icode.h>\n";
    print "void i_xlate (v_code *self) { }\n";
    $ev = -1;
} else {
    &gen_header();
    &gen_xlators();
    &gen_footer();
    $ev = 0;
}
close(OUTF);
exit($ev);
