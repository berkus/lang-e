/* $Id: tickc-rts.c,v 1.5 1998/05/17 20:34:44 maxp Exp $ */

#include <stdarg.h>
#include <string.h>
#include "tickc-rts.h"

/*
 * Debug info
 */

static int _tc_debugp;		/* Debug flag */
static int _tc_ninsn;		/* Number of insns generated by last compile */

				/* Visible to user: no leading '_' */
void tc_debugon (void)  { _tc_debugp = 1; }
void tc_debugoff (void) { _tc_debugp = 0; }
unsigned int tc_ninsn (void) { return _tc_ninsn; }

void tc_setcachesize (unsigned int s) { i_setcachesize(s); }

void tc_bpo_on (void) { v_bpo_on(); }
void tc_bpo_off (void) { v_bpo_off(); }

enum { endClosures = 1, endIIR = 2 };
static int _tc_phase;		/* For benchmarking */
void tc_end_closures (void) { _tc_phase = endClosures; }
void tc_end_IIR (void)  { _tc_phase = endIIR; }

/*
 * Runtime system state and code generation mode
 */

int _tc_leafp;			/* True if current dynamic func is a leaf */
static int _tc_init;		/* True if icode has been initialized in this
				   context */

/*
 * Dynamic call contexts
 */

static _tc_dcall_t _tc_dcc[TC_MAXCALL], *_tc_dcp = &_tc_dcc[0];

/* _tc_push_init: initialize a dynamic call context */
_tc_dcall_t *_tc_push_init (void) {
     _tc_dcall_t * dcc;
     if ((dcc = _tc_dcp++) > &_tc_dcc[TC_MAXCALL])
	  v_fatal("push_init: no more call contexts available.\n");
     dcc->argnum = 0;
     return dcc;
}

/* _tc_push: add a new argument of type type to dynamic call context dcc;
   the third argument is the pointer to the closure for this argument */
void _tc_push (_tc_dcall_t *dcc, int type, ...) {
     _tc_closure_t c;
     int i;
     va_list ap;

				/* Ensure we have enough params */
     if ((i = dcc->argnum++) >= TC_MAXPARAM)
	  v_fatal("push: out of argument slots for call context.\n");

     va_start(ap, type);	/* Get the closure for the argument */
     c = va_arg(ap, _tc_closure_t);
     va_end(ap);

     dcc->closures[i] = c;	/* Store the argument in the call context */
     dcc->argtypes[i] = type;
}

/* _tc_arg: set the kth argument in dynamic call context dcc, giving it type
   type; the fourth argument is the pointer to the closure for this argument */
void _tc_arg (int k, _tc_dcall_t *dcc, int type, ...) {
     _tc_closure_t c;
     va_list ap;

				/* Ensure we have enough params */
     if (k >= TC_MAXPARAM)
	  v_fatal("arg: arg slot %d exceeds limit (%d).\n", k, TC_MAXPARAM-1);
     if (dcc->argnum <= k)
	  dcc->argnum = k+1;

     va_start(ap, type);	/* Get the closure for the argument */
     c = va_arg(ap, _tc_closure_t);
     va_end(ap);

     dcc->closures[k] = c;	/* Store the argument in the call context */
     dcc->argtypes[k] = type;
}

/* _tc_dargs: generate code for pushing the dynamic args specified by dcc */
void _tc_dargs (_tc_dcall_t *dcc) {
     int i, k = dcc->argnum;
				/* List of closures */
     _tc_closure_t *c = dcc->closures;
     int *t = dcc->argtypes;	/* List of argument types */

     for (i = 0; i < k; i++)	/* Traverse arg type list; result of calling
				   each closure is put in an arg slot */
	  switch(t[i]) {
	  case TC_C: case TC_S: case TC_I:
	       i_argi((*c[i]->code)((void*)c[i])); break;
	  case TC_UC: case TC_US: case TC_U:
	       i_argu((*c[i]->code)((void*)c[i])); break;
	  case TC_L:
	       i_argl((*c[i]->code)((void*)c[i])); break;
	  case TC_UL:
	       i_argul((*c[i]->code)((void*)c[i])); break;
	  case TC_P:
	       i_argp((*c[i]->code)((void*)c[i])); break;
	  case TC_F:
	       i_argf((*c[i]->code)((void*)c[i])); break;
	  case TC_D:
	       i_argd((*c[i]->code)((void*)c[i])); break;
	  default:
	       assert(0);
	  }
}

/* _tc_vdargs: generate code for pushing the dynamic args specified by dcc,
   when using the vcode back end.  Similar to _tc_dargs, but uses vcode
   macros and modifies a struct v_cstate which can be manipulated directly
   by the CGF.
   (With icode, this struct v_cstate is managed implicitly by i_xlate.) */
void _tc_vdargs (_tc_dcall_t *tcd, struct v_cstate *vcs) {
     v_reg_type r;
     int i, k = tcd->argnum;
				/* List of closures */
     _tc_closure_t *c = tcd->closures;
     int *t = tcd->argtypes;	/* List of argument types */

     for (i = 0; i < k; i++) {	/* Requires that [iv]code types be the same */
	  r = (c[i]->code)((void*)c[i]);
	  v_arg_push(vcs, t[i], r);
	  v_putreg(r, t[i]);
     }
}

/*
 * Dynamic labels/jumps
 */

/* extendlist: extend homogeneous list (with elements of type elty,
   current length cur and limit length lim) with new element el.
   inc is the increment with which to lengthen list when needed.
   Can be used when list=cur=lim=0 (to initialize a list). */
#define extendlist(elty, list, el, cur, lim, inc) do {			\
     assert(el && cur <= lim);						\
     if (cur == lim) {							\
	  elty *nl;		/* New list */				\
	  elty *ol = list;	/* Old list */				\
	  elty *l = ol+cur;	/* Limit of old list */			\
	  lim += inc;		/* Increase limit of old list */	\
	  NEW(nl, lim);		/* Get new list */			\
				/* Copy old to new */			\
	  for (list=nl; ol < l; *nl++ = *ol++);				\
     }									\
     list[cur++] = el;		/* Add element to list */		\
} while (0)

				/* Should be same as icode and vcode */
static _tc_cspec_t *_tc_dtargets;
static unsigned int _tc_curtarg;
static unsigned int _tc_maxtarg;

/* _tc_mktarget: add cspec c to the list of dynamic targets */
void _tc_mktarget (_tc_cspec_t c) {
     c->lab = 0;		/* Mark c's label uninitialized */
				/* Add c to list of targets to process */
     extendlist(_tc_cspec_t, _tc_dtargets, c, _tc_curtarg, _tc_maxtarg, 
		TC_MAXTARG);
}

/* _tc_jump: cgf to implement jump() special form (emit jump to 3rd entry
   in closure c) */
void _tc_jump (void * c) {	/* Icode version */
     _tc_cspec_t _c = (_tc_cspec_t)c;
     _tc_cspec_t dst = (_tc_cspec_t)*((unsigned*)_c+2);
     if (!dst)
	  v_fatal("jump: destination is null.\n");
     assert(dst->lab > 0);
     i_jpi(dst->lab);
}
void _tc_jumpf (void * c) {	/* Vcode version */
     _tc_cspec_t _c = (_tc_cspec_t)c;
     _tc_cspec_t dst = (_tc_cspec_t)*((unsigned*)_c+2);
     if (!dst)
	  v_fatal("jump: destination is null.\n");
     assert(dst->lab > 0);
     v_jv(dst->lab);
}

/* _tc_label: cgf to implement label() special form (if a jump points to
   this label, emit the appropriate label) */
void _tc_label (void * c) {	/* Icode version */
     _tc_cspec_t _c = (_tc_cspec_t)c;
     if (_c->lab) i_label(_c->lab);
}
void _tc_labelf (void * c) {	/* Vcode version */
     _tc_cspec_t _c = (_tc_cspec_t)c;
     if (_c->lab) v_label(_c->lab);
}


/*
 * Locals and params
 */

_tc_cspec_t _tc_cspec;		/* Generic cspec object */

				/* Data structures for vcode implementation */
				/* Reps of locals */
_tc_loc_t _tc_llocal[TC_MAXLOCAL];
static _tc_vspec_t _tc_curloc = 0;
typedef struct {		/* Map from params to corresponding locals */
     _tc_vspec_t local;
     int allocp;
} _tc_param_t;
static _tc_param_t _tc_lparam[TC_MAXPARAM];
static _tc_vspec_t _tc_curparam;

enum { L_REGN=0, L_REGY=1, L_REGYY=10, L_PARM=100 };

/* _tc_vlocal_internal: actually allocate vcode locals, from within compilef */
static inline void _tc_vlocal_internal (_tc_loc_t *lp) {
     if (lp->type == TC_B)
	  lp->addr = v_localb(lp->size);
     else if (lp->reg == L_REGN)
	  lp->addr = v_local(lp->type);
     else
	  v_getreg(&lp->addr, lp->type, V_VAR);
}

				/* ICODE/VCODE implementation */

/* _tc_local: return a local vspec of type type */
				/* Icode version */
_tc_vspec_t _tc_local (unsigned long flags, unsigned int type) {
     if (!_tc_init) {
	  i_init(TC_CODESIZE); ++_tc_init;
     }
     return i_local(flags, type);
}
				/* Vcode version */
inline _tc_vspec_t _tc_localf (unsigned long flags, unsigned int type) {
     if (_tc_curloc >= TC_MAXLOCAL)
	  v_fatal("local: out of locals.\n");
     _tc_llocal[_tc_curloc].type = type;
     if (flags & TC_MEMORY)
	  _tc_llocal[_tc_curloc].reg = L_REGN;
     else if (flags & TC_REGISTER)
	  _tc_llocal[_tc_curloc].reg = L_REGYY;
     else
	  _tc_llocal[_tc_curloc].reg = L_REGY;
     _tc_llocal[_tc_curloc].size = 0;
     return _tc_curloc++;
}


/* _tc_localb: return a local vspec for an aggregate of size bytes */
				/* Icode version */
_tc_vspec_t _tc_localb (unsigned int size) {
     if (!_tc_init) {
	  i_init(TC_CODESIZE); ++_tc_init;
     }
     return i_localb(size);
}
				/* Vcode version */
_tc_vspec_t _tc_localbf (unsigned int size) {
     if (_tc_curloc >= TC_MAXLOCAL)
	  v_fatal("local: out of locals.\n");
     _tc_llocal[_tc_curloc].type = TC_B;
     _tc_llocal[_tc_curloc].size = size;
     _tc_llocal[_tc_curloc].reg = L_REGN;
     return _tc_curloc++;
}


/* _tc_param: return a vspec for parameter argno having type type */
				/* Icode version */
_tc_vspec_t _tc_param (unsigned int type, unsigned int argno) {
     if (!_tc_init) {
	  i_init(TC_CODESIZE); ++_tc_init;
     }
     return i_paramn(type, argno);
}
				/* Vcode version */
_tc_vspec_t _tc_paramf (unsigned int type, unsigned int argno) {
     _tc_vspec_t id;
     if (argno >= I_MAXPARAM)
	  v_fatal("param: out of parameters.\n");
     id = _tc_localf(0, type);
     _tc_llocal[id].reg = L_PARM;
     _tc_lparam[argno].local = id;
     _tc_lparam[argno].allocp = 1;
     v_param_alloc(argno, type, &_tc_llocal[id].addr);
     if (argno >= _tc_curparam)
	  _tc_curparam = argno+1;
     return id;
}

/*
 * Compile
 */

_tc_code_t _tc_cp;		/* Pointer to current dynamic code segment */

enum { TC_HASHSIZE=256 };	/* Size of hash table */

typedef struct {		/* Hash table of existing code segments */
     struct hte {
	  _tc_code_t cp;	/* Hash key: address of head of heap region */
	  unsigned int offset;	/* Offset for random code segment start */
	  struct hte *link;	/* More buckets */
     } *buckets[TC_HASHSIZE];
} ht;

static ht _tc_codes;

/* _tc_addcode: add dynamic code segment starting at addr "cp" to code table;
   "offset" is offset *in bytes* from beginning of memory chunk to cp. */
static inline void _tc_addcode (_tc_code_t cp, unsigned int offset) {
     unsigned long h = (unsigned long)cp&(TC_HASHSIZE-1);
     struct hte *e;

     PNEW(e, 1);		/* Allocate in permanent arena */
     e->cp = cp;
     e->offset = offset;
     e->link = _tc_codes.buckets[h];
     _tc_codes.buckets[h] = e;
}

extern void *malloc (unsigned int);

static inline void _tc_cleanup_compile (void) {
     _tc_dcp = &_tc_dcc[0];	/* Clear dynamic call contexts */
     _tc_curtarg = 0;		/* Reset label counters */
     _tc_maxtarg = 0;
     _tc_init = 0;		/* Reset state */
}

/* _tc_compile: compile a cspec */
				/* Icode version */
_tc_ip_t _tc_compile (_tc_cspec_t cs, int type) {
     v_iptr ip;			/* Should be the same as _tc_ip_t */
     unsigned int offset;	/* Random offset for code pointer */
     unsigned int i;

     if (_tc_phase == endClosures) {
	  _tc_cleanup_compile();
	  i_reset();
	  return (_tc_ip_t)0;	/* For benchmarking closures */
     }

     if (_tc_debugp)		/* Turn on icode verbose mode if necessary */
	  i_debug_on();
     else
	  i_debug_off();
     
     if (!_tc_init)		/* Initialize icode state */
	  i_init(TC_CODESIZE);
     
     if (_tc_curtarg) {		/* Create dynamic labels */
	  i_mklabel();		/* Throw away label 0 */
	  for (i=0; i < _tc_curtarg; i++)
	       if (_tc_dtargets[i]->lab == 0)
		    _tc_dtargets[i]->lab = i_mklabel();
     }

     cs->code((void *)cs);	/* Generate icode IR this cspec */
     i_end();			/* End code generation */

     if (_tc_phase == endIIR) {
	  _tc_cleanup_compile();
	  i_reset();
	  return (_tc_ip_t)0;	/* For benchmarking icode IR */
     }
				/* Optimize, ralloc, emit the generated code */
     ip = i_emit(&offset, &_tc_ninsn).i;
				/* ip==0 if i_end_{lv, etc.} */
     if (ip && _tc_debugp)	/* Dump emitted code if necessary */
	  v_dump((void*)ip);

     _tc_cleanup_compile();
     i_reset();
				/* Add code to dynamic code segment table */
     if (ip) _tc_addcode((_tc_code_t)ip, offset);
     return ip;			/* Return the function pointer */
}
				/* Vcode version */
extern void srandom (int);
extern long random (void);
_tc_ip_t _tc_compilef (_tc_cspec_t cs, int type) {
     v_iptr ip;			/* Should be the same as _tc_ip_t */
     unsigned int i;
     unsigned int sz;
     _tc_param_t *pp;
     _tc_loc_t *lp;
     static int sr = 0;		/* Flag whether random() needs a seed */
     unsigned int roff;		/* Random offset for code pointer */

     if (_tc_phase == endClosures) {
	  _tc_cleanup_compile();
	  tc_adealloc();	/* Deallocate closures */
	  v_reset_closure_state();
	  for (pp=&_tc_lparam[0]; pp < &_tc_lparam[_tc_curparam]; pp++)
	       pp->allocp = 0;
	  _tc_curparam = _tc_curloc = 0;
	  return (_tc_ip_t)0;	/* For benchmarking closures */
     }
				/* Allocate code buffer, not from the arena */
     _tc_cp = (_tc_code_t)malloc(TC_CODESIZE+i_cachesize);
     if (_tc_cp == NULL)
	  v_fatal("compile: out of memory.\n");

     if (!sr) {			/* Give random() a seed if needed */
	  srandom(4); sr = 1; 
     } 				/* Bump the code pointer randomly */
     roff = (unsigned)random();
     roff = i_cachealign(roff);
     _tc_cp = (_tc_code_t)((char *)_tc_cp+roff);
				/* Ensure all params are allocated */
     for (pp=&_tc_lparam[0]; pp < &_tc_lparam[_tc_curparam]; pp++)
	  if (!pp->allocp)
	       v_fatal("compile: parameter %d has not been allocated.\n",
		       pp-&_tc_lparam[0]);
				/* Start vcode code gen */
     v_clambda("", _tc_leafp ? V_LEAF : V_NLEAF, _tc_cp, TC_CODESIZE);
				/* Allocate locals */
     for (lp=&_tc_llocal[0]; lp < &_tc_llocal[_tc_curloc]; lp++)
	  if (lp->reg==L_REGYY)	/* Top pick goes to 'register' locals */
	       v_getreg(&lp->addr, lp->type, V_VAR);
     for (lp=&_tc_llocal[0]; lp < &_tc_llocal[_tc_curloc]; lp++)
	  if (lp->reg <= L_REGY)
	       _tc_vlocal_internal(lp);

     if (_tc_curtarg) {		/* Create dynamic labels */
	  v_genlabel();		/* Throw away label 0 */
	  for (i=0; i < _tc_curtarg; i++)
	       if (_tc_dtargets[i]->lab == 0)
		    _tc_dtargets[i]->lab = v_genlabel();
     }
     cs->code((void *)cs);	/* Generate code for this cspec */
     ip = v_end(&sz).i;		/* Link */
     _tc_ninsn = sz / sizeof *v_ip;
				/* Clear locals and params */
     for (pp=&_tc_lparam[0]; pp < &_tc_lparam[_tc_curparam]; pp++)
	  pp->allocp = 0;
     _tc_curparam = _tc_curloc = 0;

     if (ip && _tc_debugp)	/* Dump emitted code if necessary */
	  v_dump((void*)ip);

     _tc_cleanup_compile();
     tc_adealloc();		/* Deallocate closures */

				/* Add code to dynamic code segment table */
     _tc_addcode((_tc_code_t)ip, (char *)ip-((char *)_tc_cp-roff));
     return ip;			/* Return the function pointer */
}


extern int free (void *);	/* Prototype for system free() */

/* _tc_decompile: remove dynamic code segment beginning at cp from code 
   table, and free the corresponding memory */
void _tc_decompile (_tc_code_t cp) {
     unsigned long h = (unsigned long)cp&(TC_HASHSIZE-1);
     struct hte *e, *n;
     
     if (!cp) return;		/* For benchmarking */

     e = _tc_codes.buckets[h];
     if (e) {
	  if (e->cp == cp) {
	       _tc_codes.buckets[h] = e->link;
	       free((void *)(((char *)e->cp)-e->offset));
	       return;
	  }

	  for (n = e->link; n; e = e->link, n = n->link)
	       if (n->cp == cp) {
		    e->link = n->link;
		    free((void *)(((char *)n->cp)-n->offset));
		    return;
	       }
     }
     v_fatal("decompile: argument is not a dynamically generated function.\n");
}
